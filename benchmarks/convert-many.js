/** Convert results jtl to hlog */

import fs from 'fs';
import path from 'path';
import { parse } from 'csv-parse/sync';
import hdr from 'hdr-histogram-js';


const INPUT_DIRECTORY = "./results";
const OUTPUT_DIRECTORY = path.resolve('./logs');
const AGGREGATION_INTERVAL_MS = parseInt(process.argv[3]) || 1000;

fs.mkdirSync(OUTPUT_DIRECTORY, { recursive: true });

function convertJTLToHistogramLog(filePath) {
  let parsedRecords;
  try {
    const fileContents = fs.readFileSync(filePath, 'utf8');
    parsedRecords = parse(fileContents, { columns: true, skip_empty_lines: true });
  } catch (error) {
    console.error(`Failed the reading ${filePath}: ${error.message}`);
    return;
  }

  const latencyBuckets = new Map();
  let invalidRowsCount = 0;

  for (const record of parsedRecords) {
    const timestamp = parseInt(record.timeStamp);
    const latency = parseInt(record.elapsed);
    if (isNaN(timestamp) || isNaN(latency)) {
      invalidRowsCount++;
      continue;
    }

    const bucketKey = Math.floor(timestamp / AGGREGATION_INTERVAL_MS) * AGGREGATION_INTERVAL_MS;
    if (!latencyBuckets.has(bucketKey)) latencyBuckets.set(bucketKey, []);
    latencyBuckets.get(bucketKey).push(latency);
  }

  const outputLines = [];
  outputLines.push('#[Histogram log format version 2.0]');
  outputLines.push('# Units: Latencies in milliseconds');
  outputLines.push('# Generated by batch jtl-to-hlog script');
  outputLines.push('"StartTimestamp","Interval_Length","Tag","Compressed_Histogram"');

  for (const [bucketStartTime, latencies] of [...latencyBuckets.entries()].sort()) {
    const histogram = hdr.build({ lowestDiscernibleValue: 1, highestTrackableValue: 60000, numberOfSignificantValueDigits: 3 });
    latencies.forEach(value => histogram.recordValue(value));
    const compressedHistogram = histogram.encodeIntoCompressedBase64();
    outputLines.push(`${bucketStartTime},${AGGREGATION_INTERVAL_MS},"from_jtl","${compressedHistogram}"`);
  }

  const relativePath = path.relative(process.cwd(), filePath);
  const sanitizedName = relativePath
    .replace(path.extname(relativePath), '')
    .replace(/[\\/]/g, '_')
    .replace(/\s+/g, '-')
    .replace(/[^a-zA-Z0-9_\-]/g, '');
  const outputFilePath = path.join(OUTPUT_DIRECTORY, `out_${sanitizedName}.hlog`);

  try {
    fs.writeFileSync(outputFilePath, outputLines.join('\n'));
    console.log(`Wrote ${outputFilePath} (${latencyBuckets.size} histograms, ${invalidRowsCount} skipped rows)`);
  } catch (error) {
    console.error(`Failed to write ${outputFilePath}: ${error.message}`);
  }
}

function findAllJTLFiles(directoryPath) {
  const matchedFiles = [];
  const directoryEntries = fs.readdirSync(directoryPath, { withFileTypes: true });
  for (const entry of directoryEntries) {
    const fullPath = path.join(directoryPath, entry.name);
    if (entry.isDirectory()) {
      matchedFiles.push(...findAllJTLFiles(fullPath));
    } else if (entry.isFile() && entry.name.endsWith('.jtl')) {
      matchedFiles.push(fullPath);
    }
  }
  return matchedFiles;
}

// === MAIN ===
const jtlFilePaths = findAllJTLFiles(INPUT_DIRECTORY);
console.log(`Found ${jtlFilePaths.length} .jtl files in ${INPUT_DIRECTORY}`);

for (const filePath of jtlFilePaths) {
  convertJTLToHistogramLog(filePath);
}
